---
title: "数据操作"
---
## 0.1. 生成数据样本
可以使用 arange 创建一个行向量 x。
```
x = torch.arange(12)
```
除非额外指定，新的张量将存储在内存中，并采用基于CPU的计算。
```
x.shape # shape属性输出x的形状
x.numel() # 输出张量中的元素总数
X = x.reshape(3, 4) # 要想改变一个张量的形状而不改变元素数量和元素值，可以调用reshape函数。
```
> 我们可以通过-1来调用此自动计算出维度的功能。 即我们可以用x.reshape(-1,4)或x.reshape(3,-1)来取代x.reshape(3,4)。

### 0.1.1. 创建一些特殊的张量
> 全0张量
```
torch.zeros((2, 3, 4))
```

> 全1张量
```
torch.ones((2, 3, 4))
```

> 高斯分布
```
torch.randn(3,4) # 3行4列
torch.randn(size=()) # 生成一个标量
torch.randn(size=(4,))  #生成一个向量
```

> Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值。
```
torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
```

## 0.2. 运算符
对于任意具有相同形状的张量， 常见的标准算术运算符（$+、-、*、/和**$）都可以被升级为按元素运算。 
```
x = torch.tensor([1.0, 2, 4, 8])
y = torch.tensor([2, 2, 2, 2])
x + y, x - y, x * y, x / y, x ** y  # **运算符是求幂运算
```
“按元素”方式可以应用更多的计算，包括像求幂这样的一元运算符。
```
torch.exp(x)
```

> 把多个张量连结（concatenate）在一起， 把它们端对端地叠起来形成一个更大的张量。
```
# 提供张量列表，并给出沿哪个轴连结。
X = torch.arange(12, dtype=torch.float32).reshape((3,4))
Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)
```